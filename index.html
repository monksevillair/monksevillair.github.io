<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Ensures proper scaling on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monk's Evil Lair - Force Directed Graph</title>
    <!-- Include D3 (v7) from CDN -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      /* Fullscreen and background */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background-color: #111;
        overflow: hidden;
      }
      svg {
        width: 100%;
        height: 100%;
      }
      /* Link styling (the lines connecting nodes) */
      .link {
        stroke: #666;
        stroke-width: 2px;
      }
      /* Node styling */
      .node circle {
        fill: #000;  /* Black background for bubbles */
        stroke: #fff;
        stroke-width: 2px;
      }
      .node text {
        fill: #fff;  /* White text */
        font-family: Arial, sans-serif;
        font-size: 14px;
        pointer-events: none;
        text-anchor: middle;
        dominant-baseline: central;
      }
      /* Central node (spinning logo) */
      .center-image {
        pointer-events: none; /* Do not capture clicks on the image */
      }
      .rotate {
        transform-origin: center;
        animation: spin 8s linear infinite;
      }
      @keyframes spin {
        from { transform: rotate(0deg); }
        to   { transform: rotate(360deg); }
      }
      /* Make cursor a pointer for clickable nodes */
      .clickable {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <svg></svg>
    <script>
      // Get viewport dimensions
      let width = window.innerWidth;
      let height = window.innerHeight;

      // Define nodes:
      // The central node (isCenter = true) displays the logo image.
      // Other nodes represent categories with their respective URLs.
      const nodes = [
        { id: "center", isCenter: true },
        { id: "blog", url: "/blog2/" },
        { id: "home", url: "index.html" },
        { id: "jazz", url: "jazz/jazz.html" },
        { id: "music", url: "music/music.html" },
        { id: "radio", url: "radio/radio.html" },
        { id: "study", url: "study/study.html" },
        { id: "transcriptions", url: "transcriptions/transcriptions.html" },
        { id: "语言", url: "语言/语言.html" }
      ];

      // Define links: every non-center node is linked to the center node.
      const links = nodes
        .filter(d => !d.isCenter)
        .map(d => ({ source: "center", target: d.id }));

      // Create the force simulation.
      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(150))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .on("tick", ticked);

      // Select the SVG element.
      const svg = d3.select("svg");

      // Create the link elements.
      const link = svg.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link");

      // Create groups for nodes.
      const node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", d => "node" + (!d.isCenter && d.url ? " clickable" : ""))
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      // For the central node, append an image.
      node.filter(d => d.isCenter)
        .append("image")
          .attr("xlink:href", "./src/templates/images/dozehilz.png")
          .attr("width", 100)
          .attr("height", 100)
          .attr("x", -50)  // Center the image relative to the node's position.
          .attr("y", -50)
          .attr("class", "center-image rotate");

      // For non-central nodes, append a circle and text label.
      const nonCenter = node.filter(d => !d.isCenter);
      nonCenter.append("circle")
          .attr("r", 40);
      nonCenter.append("text")
          .text(d => d.id);

      // Add click handler to non-center nodes.
      nonCenter.on("click", (event, d) => {
        if(d.url) {
          window.location.href = d.url;
        }
      });

      // Update positions on each simulation tick.
      function ticked() {
        // Force the center node to remain at the center.
        nodes.forEach(d => {
          if(d.isCenter) {
            d.x = width / 2;
            d.y = height / 2;
          }
        });
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);
        node.attr("transform", d => `translate(${d.x},${d.y})`);
      }

      // Drag event handlers.
      function dragstarted(event, d) {
        // Do not allow dragging of the center node.
        if(d.isCenter) return;
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        if(d.isCenter) return;
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if(d.isCenter) return;
        if (!event.active) simulation.alphaTarget(0);
        // Remove fixed positions on drag end so that nodes return to equilibrium.
        d.fx = null;
        d.fy = null;
      }

      // Update simulation on window resize.
      window.addEventListener("resize", () => {
        width = window.innerWidth;
        height = window.innerHeight;
        simulation.force("center", d3.forceCenter(width / 2, height / 2));
        simulation.alpha(1).restart();
        svg.attr("width", width).attr("height", height);
      });
    </script>
  </body>
</html>
